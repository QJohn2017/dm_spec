Time-dependent propagation of density matrix of 2-level dimer system.

Reference:
Two-dimensional optical three-pulse photon echo spectroscopy. I. Nonperturbative approach to the calculation of spectra

Tomas Mancal, Andrei V. Pisliakov and Graham R. Fleming

J. Chem. Phys. 124, 234504 (2006).

For the 2D spectroscopy calculation, one refer to the formula (4) in the papar, that is why we need BACKWARD (exp(+ i w_t t)) then use FORWARD (exp(- i w_tau tau)) for the FFT (still don't quite understand why they need to have opposite signs...).

Structure of the code:
directory ./src is used for C++ source code.
directory ./inc is used for headers.
directory ./raw is used to store all results by MPI calculation.
directory ./res is used to store results of single calculation and processed results from MPI calculation.
directory ./fig is used to keep images generated by Python scripts.

------------------------------------------------------------
Standalone and MPI:
Switching between single / MPI computation:
Change ./src/Makefile: 
1. main_single.cc <-> main_mpi.cc
2. substitution of variables: $(CC), $(CFLAGS), $(LFLAGS)

------------------------------------------------------------
Git is used to manage the source code and deployment. 
The main repository is at "/data1/home/tianmin/project/git/dm_2lv/". 
* Start working in a new working directory:
    git clone /data1/home/tianmin/project/git/dm_2lv/
* After some modification, submit the code:
    git add .
    git commit -m "Some comment about the modification."
    git push
* Don't forget to pull from the repository before working on it:
    git pull
* Try another branch before merging:
    git checkout -b name_of_branch
    git checkout

------------------------------------------------------------
TODO List
the following two functions need modification for arguments
The size of "ppar", "ptot" are changed from n_phase * nt to n_phase * nt * n_dim


DONE: partial_polar( ppar[idir], ptot, ps, idir ) 
DONE: total_polar_from_ME( ptot[i_phase], rho, ps )
void plot_ppar( ppar, ps )

DONE: I want to dynamically bind the struct parameters, which can be referred to 
either a monomer or a dimer. In order to solve different problem within 
the framework, we can tell compiler to build from different files which 
contain the same data types, which are, however, implemented differently.
E.g., para.h and para.cc

DONE: Now I want to extend mu to multiple site
mu[i_site][i_coord] note: file main_mpi.cc was not modified.

Now I want to extend mu to multiple site
Esite[i_site][i_coord]

DONE: The new variables for dimer
    // new variables for dimer system
    double E_site[2];
    double J_couple;
    double g_couple;
    double w_cutoff;
    double *mu_site[2];
    double temperature;

The coordinates transform should implemented.


I need to apply the representation transformation:
site rep. -> exciton rep.


variables:
DONE: kuvx -> kuvxL
DONE: kuv -> kuvL, kuvM
DONE: r -> rM, rL
DONE: 2D array for EuvL and EuvM
DONE: Euv -> EuvL, EuvM
TODO: use macro to rewrite the N_SIZE


DONE: define the rotation matrix
DONE: allocation for the different parameter structures - bath, rep, coord.
DONE: define rep structure, assign values to it
TODO: put all declarition of structures for bath and coord into 
    respective folders of subsystems.
DONE: define the dipole mu in parameters.
DONE: remove "n_site" since it is irrelevant to the universal framework.
DONE: subsystem bath: g_couple

TODO: the numerical ODE is still NOT reliable. Find the benchmark.
RK4 with small step so far seems trackable. Try to make the 1D spectrum converge.

It seems the density matrix elements are convergent, but I found large descrepency
between high-order partial polarization. 
Since the coefficients are invariant, 
* Firstly, calculate total polarization and compare if total polarizations are the same. 
- There is difference, seems due to the round-off error

* We will compare density matrix element between different step sizes.
- The evolution of the density matrix elements also proves the seemly round-off error.

* Now the question is, without dissipation, why the coherence and population fade away?
- It makes sense since the polarizations are all from stimulated emissions, which ae only available when the external light fields are applied (at least for the 1st oorder linear terms). As for the 3rd order terms we still need to check. 

* What is the EXACT definition of PHOTON ECHO spectroscopy? I need to understand
    in which temporal part I need the information of the polarization, and Fourier
    transform which.

* What is used for the nonhomogenous broadening in the density matrix?

* I need to analyze the equation structure











TODO: Is that possible to find Bloch vector?
    the
     - animation for the photon echo

In order to make the code flexible for further development, we need to 
keep the core relatively seperated from other modules. The core should 
be a independent density matrix solver, which is essentially a ODE solver.
The premitive model should be like:

Fixed parts:

* energy levels: array
* transition dipoles between specified energy levels: array
* relation between the laboratory coordinates and the system coordinates: angles
* overall polarization
* partial polarization

Problem specific parts:
* external light fields
* bath model

One can use extra data structures in the main "parameters" structure, as long as
one assign the specific pointers of these extra structures to the main one.

------------------------------------------------------------
Progress.

We are mainly working on the dimer system.

In the first stage, we focus on the perturbation method,
The 2D spectroscopy is calculated from the response function which contains
the four-point time correlation funcition.

In the second stage, we have turned into the time-dependent view. We
solve the reduced density matrix. The nonlinear signal is extracted from the
the method reported by Wolfgang Domeck's group. The nonlinear signal 
calculated with time propagation is the total polarization. But it can be 
decomposed into different directions, say, each direction is a basis, the signal
in the corresponding direction is the coefficient.

Eg. the photon echo one is -1, 1, 1, CARS is 1, -1, 1 for different directions.
The output


* Intuitively, one can see how the system evolves
* Natural to consider polarization control, involing transform between lab & mol.
* It is straightforward to incorportate different levels of approximations. Eg. the chromophore-bath interaction can be described by emperical paramters or the redfield tensor.
* The bridge between the feynman path and time-dependent perspectives from the directional k \dot r terms.
* With the time-dependent method, we can include the finit pulse-width effect beyond the impulse limit.


------------------------------------------------------------
Some compiler options for different architechures
# # for wellington: 139.165.105.132
# CC	=	mpiicc

# # The following configuration is for the intel icc on the cluster
# CFLAGS	=	-Wall -g -I../inc -I/cm/shared/apps/mvapich2/intel/64/1.6/include/ -I/cm/shared/apps/fftw/intel/64/3.2.2/include/
# LFLAGS	=	-lmpich -lifcore /cm/shared/apps/lapack/intel/64/3.3.0/liblapack.a /cm/shared/apps/blas/intel/1/lib64/libblas.a /cm/shared/apps/fftw/intel/64/3.2.2/lib/libfftw3.a

# for pinot: 139.165.105.191
# CC	=	mpicxx
# CFLAGS	=	-g -Wall -I../inc
# LFLAGS	=	/data1/home/tianmin/software/lapack/lib/liblapack.a /data1/home/tianmin/software/lapack/lib/librefblas.a /data1/home/tianmin/software/fftw3/lib/libfftw3.a /usr/lib64/gcc/x86_64-suse-linux/4.3/libgfortran.a


# # The default one for the laptop
# CC		=	g++
# CFLAGS	=	-Wall -g -I../inc
# LFLAGS	=	-lfftw3 -llapack

#/home/tianmin/temp/lapack-3.4.2/liblapack.a \

------------------------------------------------------------
The new Makefile specify the absolute path
one can choose different systems.
The following option in Makefile will choose monomer.
IDX_MODL	=	1

------------------------------------------------------------
All parameters structures (including the systems) appearing in the 
main "parameters" structure should be declared in para.h.
The customized structures, e.g., parameters_local for repr sub-system, 
should be declared in sub-system headers.

set_para( para ) (setup.cc)

    - here we set sizes of variables which need allocations.

    ini_para()
        ini_para_coord
        ini_para_repr
        ini_para_bath
        ini_para_efield
    
    - here we assign values to parameters.

    set_para_coord()
    set_para_repr( para, para_local )
    set_para_core( para )
    set_para_bath( para )

    set_para_efield_lab( para )
    set_para_efield_mol( para )

del_para( para )
    del_para_efield
    del_para_bath
    del_para_repr
    del_para_coord

------------------------------------------------------------
The core variables and modules to be defined:

* energy
* dipole

* eom

sub-systems
coord.
repr.
bath


The standard workflow:

- abstract setup:

1. set abstract structure of system:
    * N_LVL (system.cc)
    * N_DPL and coupling structure (system.cc)
    * EOM with interacton V_ij (eom.cc)

- concrete setup:

2. set system
    * system parameters (setup.cc)
        energies, dipoles, orientations, positions
    * time parameters (setup.cc)
        t0, t1
    * measure parameters (measure.cc)
        tau, T, t

3. set external light field
    * field parameters (setup.cc)
        n_pulse, E0[i], W[i], FWHM[i], k_dir[i], E_dir[i], shape[i], et al

4. set bath
    * bath parameters (setup.cc)

------------------------------------------------------------
main_mpi_2.cc: Calculation of ensemble of molecules for 2D spectroscopy

Each thread calculate a certain range of tau within [0,tau_max]
* Read in MPI information (how many nodes are available)
* Calculate n_tau for the current node (NOT equal to total one ps.n_tau)
* Allocation of memory:
    ppar_esmbl[n_nphase][n_tau*(ps.n_t)][n_dim]
    ppar_1d[n_phase][(ps.n_t)][n_dim]
* Loop over ensemble -> loop over tau : for each trajectory
    ** Setup ensemble parameters, randomize orientation et al
        see function "setup_ensemble". para_local should be fully reset
    ** Calculate tc[0] for 1st pulse center:
        - ps.tau - ps.T + (index_begin + i_tau) * ps.d_tau
    ** Calculate ppar_1d
    ** Display information of a single trajectory (COULD BE SWITCHED OFF)
        file "raw/traj_%2d.dat", see function "display_info" and output
        variable "ppar_1d"
    ** Calculate ensemble by sum over trajectories
        the index of ppar_esmbl is given by i_tau*(ps.n_t)+i_t
* Output ensemble averaged ppar
    file "raw/ppar_2d_%2d.dat". 

------------------------------------------------------------
spec_1.cc: The FFT of ppar to calculate 1D/2D spectrum

A. the old implementation:
* halve the boundary of R
* spectrum shift

B. the new implementation
* Allocation of the array:
    spec1[n_tau*n_t], spec2[n_tau*n_t]
* Setup the fft plan for fftw
* fft_1d backward
* fft_1d forward





The post-process of data
------------------------------------------------------------
ana/mpi_spec_2d/main.cc: calculate 2D spec from MPI data 

(The MPI data can be either single or ensemble averaged)
* Loop over nodes
    ** Open file "raw/ppar_2d_%2d.dat" (i_node)
    ** Loop over tau -> t -> dir -> dim
        *** Read in ppar_2d[i_dir][it][i_dim]
            where it = (index_begin + i_tau) * (ps.n_t) + i_t
* Loop over i_dir -> i_dim
    ** Output variable ppar_2d[i_dir][it][i_dim]
        to file "res/ppar_2d_%2d_%1d.dat" (i_dir, i_dim)
        where it = (ps.n_tau-i_tau-1) * ps.n_t + i_t due to reversed order
        of tau (HERE I corrected the mistake!).
        Note this i_tau is different from the i_tau above.
    ** Loop over i_dir
        output 2D spectrum with function "spec_2d" for different dir






NOW I need to add the module to dump ptot to file for the MPI calculation
backup polar_a.cc as polar_a.cc.bak, use new file main_mpi_2.cc




2014/01/29:
DONE * Continue with the documentation, add the part "calculation of spectra".
DONE * Circular shift and FFT.
* Check the orignal derivation if RWA influences the complex polarization
  If the complex polarization influences the decomposition index
  - Using 24 indices and real polarization, compare the signals for 
    k = -k1+k2+k3 and k = k1-k2-k3, why there is a shift along the 
    w_tau-axis ?
DONE * Extract signals from certain intervals from the 2D ppar/ptot file,
    and conduct the corresponding spectra calculation.
* Read paper about the 2D spectrum, check the freq position.
* Decomposition strategy, pi...
* The array assignment seems problematic when the size is large, e.g., 
    - reduce from the large array to individual loops
* The single peak?
    - lead by bath effects?
    - What if I do a half-spectrum-half-polarization (w_tau - t) plot?
        In principle, the peak should appear at 2 positions


* I need to go back to 1-D calculation..
    - compare ppar for a single tau, varing with different time steps.
    - need to find a reasonable way cut off all artifical numerical noise
        for the total polarization



28/02/2014: Calculation of 100000 trajectories for 1D photon echo spectrum
            DONE: results good with photon echo signal for [-1, 1, 1]

20/03/2014: Implement arbitarty polarization directions and wave vector 
            in laboratary frame with Euler's angle. Should be defined in
            field.h and field.cc

21/03/2014: Reduce the code size. Use template to cut redundant code: 
            coord.cc
            the parameter NE should be set where the EOM is set, in order
            to be compatible
            new file interface are implemented. all file information is
            configured at setup.cc


dm_2014_04_04: Try to figure out the oscillation is artificial or physical
using finer temporal grid so we can the signal still has some interesting
structure.

dm_none2: 
    * Reorganize the project.
    * Carry out 1D fourier transform with python
        script. Thus one can choose the domain to transform more conve-
        niently.

10/04/2014: Find out the influence of population/coherence transfer
    * find out the relation between bath parameters & transfer rate

    change E0 = 1e-4 -> 1e-3
           bath->w_cut = 50 -> 500
           t1 = 500 -> t1 = 4500
           nt = 1400 -> 6000
    Long population time T is used: T= 100 -> T= 800

    Note: coupling between monomers, J, should be present for the presence
            of the population transfer rate


09/05/2014:
* A new method should be implemented according to:
    B. Bruggemann, P. Kjellberg and T. Pullerits, 
    Chem. Phys. Lett 444, 192 (2007)
  which should largely reduce the computational time for ensemble study
  and have a better interpretation briging between single system and
  the whole ensemble in terms of FT of the spatial position.
    I need to separate the parital polarization from the main routine,
    and use the ppar calculation as an optional module.


* Modify the code for the 2D mapping: x-spectrum y-delay time for pump-probe


I did the code modification that 
prepare_pol_array_2d( long nx, long ny, parameters *ps )
becomes
prepare_pol_array( ng, parameters *ps );
where ng = nx * ny
The same modification should also be done for 
clean_pol_array_2d

In calc_ptot, an extra argument ig is used to indicate the starting index
for multi-dimensional data. The difference between indice ip and ig:

pol[nt*ns*...][n_dim]

ip: used to indicate an extra dimension of pol[nt*ns][n_dim], the tag for the extra rho calculation
ig: used to indicate the starting position in nt*ns, number of grids in 

for seidner:  pol[n_phase][ng][n_dim]
for generic:  pol[ng][n_dim]




14/05/2014:
I have some idea about how to organize the configuration of each module so
that we don't need to modify parameters in the header file which may leads
to long compilation time
The module file should be xxx.cc
The config file for this module is xxx_cfg.cc
In the future, the parameters may be read from real config file.
I need to look at mvar.cc esmb.cc main_mpi_esmb to figure out how to
implement the new method.


* Remove N_PHASE from cfg/system.h. n_phase is set at src/seidner_cfg.cc
* iphi dependence is remove from field.cc, performance is enhanced.
 also need to change argument list of field_real_components(...)
 remember to add assignment routine for ef->ph before prop
* All rL, rM, phiL, phiM, n_phase have been moved to "seidner" module.
  The seidner method has been decoupled from the main framwork.

15/05/2014:
All function and files that have seidner_* should have the counterpart one 
*, e.g. 
seidner_main_single.cc | main_single.cc
seidner_mvar.cc | mvar.cc

* Modification to polar data I/O operation is made.
    Header file is "output.h"
    polarization data I/O is in "pol_io.cc", which is implemented mostly
        with template.
    line operation of polarization data is in "pol_io_line.cc"
    other output function is in "output.cc"
    seidner specific output is in "seidner_io.cc"
* Line operation functions should be carefully designed for file format.

* I need to add function for 1D grid I/O. The polar data should be
    separated from the grid information

* A new type of format is added into the mvar.cc in order to use the
    algorithm. The polarization has the format:
    Re_x(t1) Im_x(t1) Re_y(t1) Im_y(t1) Re_z(t1) Im_z(t1) Re_x(t2)..    
    TODO: one needs design routine to read this format with MPI

* A new variable "pos" is added into the system. One should think
    1. how to assign value to pos, 
    2. how to output pos to file according to algorithm
    3. how to interact with the spatial phase in the laser field.
    4. should the "pos" be in the mol. or in the lab. frame for
    the algorithm?
    -- I have used the rL as the initial definition
    
    The pos in mol should be rL
    The coordinates transformation between rL and rM should be 
        "translation" -> "rotation"

16/05/2014:

* continue working on file "mvar.cc": "mvar_calc_1d"

* go back to original 3-pulse expr.. Now we have the nature extension
    for different system. 

    all the following files can be substituted by counterparts 
    in "cfg/collections":

    cfg/parameters.h should be changed
    cfg/system.h should be changed
    seidner_cfg.cc should be changed    

    polar.cc: seperate the next function from ptot_from_dm()
        ptot_from_dm_xxx( complex* pol_M, double* rho, parameters *ps )
        now we have "ptot_from_dm_org", "ptot_from_dm_7lv"
        don't forget to modify corresponding mathematica generator
        since we don't use rho[it][i_dim] but rho[i_dim]

    repr.cc: uncomment exciton_repr_4lv

    pymod_indx.py: the structure 
        "directions" -> "directions_2" and "directions_3"

    plot_ppar.py: directions_2 -> directions_3, also the range of ploting

* A new structure should be added to save the old status for "update_esmb"


* in "mvar_calc_1d", one need to modify "update_esmb"
    in "esmb.cc":
        "update_esmb": position is updated with random number.
        "emsb_setup": ps->esmb->n_esmb = 100 (the total number of samples)

    don't forget to modify the code for seidner method as well (currently
    I comment the line for seidner..)

* in "mvar.cc", ps->mvar->ny will influence it is 1D or 2D computation (
    see mpic.cc about the job assignment)
    in mvar_setup, n_tau = 400 -> n_tau = 1, and let d_tau = 0

21/05/2014:

* Now I need to introduce libconfig for parameters setup.
    - para_basic_read_config( config_t* cfg, parameters* ps )
        is used to setup basic paraemters, e.g. n_dim, n_lvl

* Check the result and introduce the new algorithm.



The function "para_ini" should contains the configuration routine
Because:    - all basic structure are specfied from cfg file
            - the structure is no longer changed during running


"parameters.cfg" should be read only for once, then all systematic size
should be determined.
"para_XXX_config" function should be used to read the above file.

Module Dependence:
    ini:
        core:       alloc: n_lvl, n_dpl, n_dim
                    config: n_dim, n_lvl, n_dpl, n_eom
                    set: 

        esmb:       alloc: NULL
                    config: n_esmb
                    set: NULL
        mvar:       alloc: NULL
                    config: ny, y0, y1. Moreover, the meaning of y should
                            be specified, e.g., tau, T, et al.
                    set: NULL
        mpic:       alloc: NULL
                    config: NULL
                    set: from main entry: rank, size 
                        esmb, mvar
                        (need to assign job for different types)
                    once init, no more changed
        coord:      alloc: n_dim
                    config: phi, theta, psi
                    set: NULL
                    
        repr:       alloc: NULL
                    config: EA, EB, J, mu, depends on model used
                            (4-lvl dimer or generic)
                    set: NULL
        
        bath:       alloc: NULL
                    config: g, w_cut, T
                    set: repr
                         repr->theta (transformation from generic to 
                            exciton)
                            Energy structure (for bath distribution calc)

        efield:     alloc: n_pulse, n_dim *
                    config: W, FWHM, Edir, kdir
                    all fields stuffs in lab frame
        seidner:    alloc: n_phase, n_dim, n_pulse
                    config: index, also pos may be defined
                    set: efield
        file:       alloc: NULL


    update:

        esmb:       NULL
                    update may change other modules

        mvar:       NULL
                    update may change other modules (not mpic)
                    update depends on mpic (but mpic is not changed)

        mpic:       NO update
                    
        coord:      NULL    phi, theta, psi
                    every time phi, theta, psi is updated, transform
                    matrix should be updated
        repr:       NULL    energy, dipole, pos
                    every time the above changed should be updated
        bath:       repr    
                    every time the above changed should be updated
        efield:     NULL
                    should be update?

        seidner:    ?

        file:       NULL    all files stuffs



2014/06/18: I remove the t output to data files (ppar_1d et al)
2014/06/24: A mistake is found in ptot_from_dm_org, the density rho should be complex but I used wrong labels considering as a complex variable instead of double rho

I tried not to transform from mol to lab in ptot_from_dm, check if the algorithm works for rotational average. It seems working now!!! Why does the transformation influence??? 
TODO: I should try to check the translation transform of absolute path.






The new method can produce double peaks for the 2D spectroscopy for the direction [-1, 1, 1].

The parameters should be properly selected:
g = 0.008, in order to keep the coherence and not let the coherence decay too fast. t > 500, in order to resolve the peak.


for the 2D spectroscopy, it is fine to use 50 fs for the tau, since we can multiply e^{-i * w * tau} to shift the original signal to 0 frequency, which help reduce the time interval, thus 50 sample points may be enough. Anyway, I need to try the FFT algorithm.





----------------------------------------
I need to specify new file format for polarizations / signals:

Each file only contains two columns, Re and Im
The number of rows is ns * nt.         nt varies fastest.
ns can be for number of ensemble, the extra dimensions
The format can be extended to higher dimensions ns -> ns1 * ns2 * ...

Re(s0,t0) Im(s0,t0)
Re(s0,t1) Im(s0,t1)
...
Re(s0,tN) Im(s0,tN)
Re(s1,t0) Im(s1,t0)
Re(s1,t1) Im(s1,t1)
...
Re(s1,tN) Im(s1,tN)
...
...
Re(sN,t0) Im(sN,t0)
Re(sN,t1) Im(sN,t1)
...
Re(sN,tN) Im(sN,tN)

EXAMPLES
There are several cases:

* Seidner's method 1D ppar: (nt) rows, (n_dir * n_dim) files
Re(t0) Im(t0)
..
Re(tN) Im(tN)

* Seidner's method 1D ptot: (nt) rows, (n_dir * n_dim) files
Re(t0) Im(t0)
..
Re(tN) Im(tN)

* Seidner's method 2D ppar: (ns * nt) rows, (n_dir * n_dim) files, 
    reduced due to sum-up over ensemble

Re(s0,t0) Im(s0,t0)
..
Re(s0,tN) Im(s0,tN)
...
Re(sN,t0) Im(sN,t0)
..
Re(sN,tN) Im(sN,tN)

or if no sum up, the format should contain individual ensemble information.
The formation will be like the following Overall phase 2D ptot.


* Seidner's method 2D ptot: Should not exist for ensemble-reduced data, 
    since cannot sum up 

* Overall phase 1D ptot: (ns * nt) rows, (n_dim) files, 
    's' represents ensembe index
Re(s0,t0) Im(s0,t0)
..
Re(s0,tN) Im(s0,tN)
...
Re(sN,t0) Im(sN,t0)
..
Re(sN,tN) Im(sN,tN)

* Overall phase 2D ptot: (ns1 * ns2 * nt) rows, (n_dim) files, 
    's' represents extra dimension

ensemble 1. 
    Re(s0,t0) Im(s0,t0)
    ..
    Re(s0,tN) Im(s0,tN)
    ...
    Re(sN,t0) Im(sN,t0)
    ..
    Re(sN,tN) Im(sN,tN)
ensemble 2. 
    Re(s0,t0) Im(s0,t0)
    ..
    Re(s0,tN) Im(s0,tN)
    ...
    Re(sN,t0) Im(sN,t0)
    ..
    Re(sN,tN) Im(sN,tN)

* Partial polarization from overall phase 1D: 
    (nt) rows, (n_dir * n_dim) files
the same as Seidner's 1D

* Partial polarization from overall phase 2D:
    (ns * nt) rows, (n_dir * n_dim) files
the same as Seidner's 2D


FILE NAME CONVENTION
For partial polarization
the name of files is "ppar_${ns}d_${dir}_${dim}.dat"
${ns}: %2d, ${ns} = 1 for nt-grid only, ${ns} = 2 for more grids are used.
${dir}: %2d, the index of direction for partial polarization
${dim}: %2d, the index of dimension

For overall polarization
the name of files is "ptot_${ns}d_${dim}.dat"

----------------------------------------
In the corresponding grid, each row mappes exactly to the signal files. 
Therefore the number of rows should agree with signal files:


s0 t0
s0 t1
...
s0 tN
s1 t0
s1 t1
...
s1 tN
...
...
sN t0
sN t1
sN tN




The file manager now considers more complicated situation:

The original file manager is kept with "one_node", maintain single file.
Multiple files sharing the same file labels are managed by "mul_node".
Now each TYPE label can refer to several files, one needs to specify
n_file for each TYPE label. Each file is named with the format 
"filename0", "filename1",
In this case, the file can be named as "ppar_coo", then they will be 
converted to "ppar_coo0", "ppar_coo1", "ppar_coo2"
The pointers are kept in FILE**fptr, instead of the single one FILE*fptr



Increasing T, the spectrum diffused, as expected.

The direction of the spectrum somehow does not agree with Mancal's paper
maybe I should do the Fourier transform without i (Pol->Ef transform)...


An idea is here to analyze the Feynman path contribution:
P = sum( mu_ij * rho_ji ), we can output each P_ij = mu_ij * rho_ij. In a
certain direction the partial polarization for each coherence can also be
obtained with Seidner's method. Reconstruct the FFT spectrum from these 
partial signal for a certain direction, then we know how much the path 
contribute to it. Sum the spectrum together, the spectrum should be 
recovered, since all involved operation are linear (Seidner, FFT).


2D FFT

1. The difference between FFT and IFFT is, the frequencies differs by a sign

2. Since the orignal data are stored in inversed order, I am not sure if the results are also stored in an inversed order.

3. No matter how the combination the FFT and IFFT is, all results should be correct, if the frequency ticks are set correctly.

In matplotlib, changing "extent" for the 2D plot does NOT change the spectrum pattern, it only changes the axis labeling - the labels can go from higher value to lower one, instead of from lower to higer one.


So far, it is seen for direction 15,
the correct pattern can be produced by 
(FFT, IFFT) -> flipud( rot270 (signal) )
The x-axis should be correct, since it is a straightforward FFT

No. the above statement is NOT justified, b/c it cannot explain the exchange
of axis label between the t and tau. Moreover, the coupled dimer result (J=-0.23) suggests the original one, just (FFT, IFFT) gives better result. I will stick to the original method. 

Now let's explain the determinatio of axis:

The x-axis is easy, just the positive half plain with increasing order. Therefore the range is given by [ x[0], x[-1] ]


The y-axis is applied with IFFT, since the data is stored with inversed order, we actually calculate the -w_tau, so the spectrum is automatically flipped to the +y plane. Thus the range is given by [ -y[-1], -y[0] ]

If we use FFT, the frequency will appear in the -y plane, we later need to 
manually do the flip to positive plane, for both the axis and the signal spectrum.




        Distinguish: the role of population transfer, the role of coupling J
        Figure out the relation between sum[P_l(phi)] and P_l(phi)
        Seidner's method: results for all directions
        Pullerits' method: disscuss proper parameters and simulations
        Vibrational effects for monomer

        1. main_mpi.cc: select method to use
                mvar_calc_grid_seidner( &ps ): seidner's method
                mvar_calc_grid( &ps ): pullerits' method

        2. esmb_update: orientation, static disorder, energy, coupling
                the position samplng diffs between methods

        3. output.cc: check the io_pol_read and io_pol_write are consistent

        4. parameters.cfg: with_old


        2014.08.29: discovery from fifth-order signal calculations

        In order to calculate high-order terms, modification has to be considered that
        different orders mu * rho must be summed up seperatedly. Check the function
        ptot_from_dm_org in file polar.cc.

        Output mu_ij * rho_ij separatedly, then sum them up. We have benifits:
        * no more suffer from round-off error during summation in Seidner's routine
        * we have signals of different paths